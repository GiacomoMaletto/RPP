\documentclass[runningheads]{llncs}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\newcommand*{\qeda}{\hfill\ensuremath{\blacksquare}}%
\newcommand*{\qedb}{\hfill\ensuremath{\square}}%
\newtheorem{fact}{Fact}[section]
\usepackage{latexsym}
\usepackage{cmll}
\usepackage{xspace}

% graphics
\usepackage{mathdots}
\usepackage{nicematrix}
\setcounter{MaxMatrixCols}{20}
\usepackage{rotating}

\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1} % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4} % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}  % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}    % green
\definecolor{aawhite}{rgb}{0.97,0.97,0.97}
\definecolor{awhite}{rgb}{0.90,0.90,0.90}
\definecolor{lgreen}{rgb}{0.94,1.0,0.98}
\definecolor{dgreen}{rgb}{0.0,0.3,0.1}
\definecolor{sgreen}{rgb}{0.0,0.7,0.3}
\definecolor{lgreen}{rgb}{0.94,1.0,0.98}
\definecolor{bgreen}{rgb}{0.00,0.50,0.25}
\definecolor{dblue}{rgb}{0.0,0.1,0.6}
\definecolor{lorange}{rgb}{1, .85, .60}
\definecolor{lblue}{rgb}{.80, .90, .95}
\definecolor{mixed}{rgb}{0.0,0.3,0.3}
\definecolor{dred}{rgb}{0.6,0.2,0.0}
\definecolor{sred}{rgb}{0.7,0.2,0.0}
\definecolor{ddred}{rgb}{0.3,0.1,0.0}
\definecolor{turq}{rgb}{0.28,0.82,0.80}
\definecolor{lyellow}{rgb}{1.00,0.97,0.94}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\usepackage{graphicx}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=sred,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=sgreen,
    bookmarks=true,
}


% code
\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}
\usepackage{float}


%\usepackage{listings}
%\renewcommand{\verb}{\lstinline}
%% Yarel related definitions
%\input{yarel-lst.tex}
%\lstdefinestyle{yarel-style}{
%	backgroundcolor=\color{backcolour},
%	commentstyle=\color{codegreen},
%	keywordstyle=\color{magenta},
%	numberstyle=\tiny\color{codegray},
%	stringstyle=\color{codepurple},
%	%	basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
%	basicstyle=\ttfamily\footnotesize,
%	breakatwhitespace=false,
%	breaklines=true,
%	captionpos=b,
%	keepspaces=true,
%	numbers=left,
%	numbersep=5pt,
%	showspaces=false,
%	showstringspaces=false,
%	showtabs=false,
%	tabsize=2
%}
%\lstset{
%	language={yarel},
%%	basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
%	basicstyle=\small\ttfamily, % Global Code Style
%	captionpos=b, % Position of the Caption (t for top, b for bottom)
%	extendedchars=true, % Allows 256 instead of 128 ASCII characters
%	tabsize=2, % number of spaces indented when discovering a tab
%	columns=fixed, % make all characters equal width
%	keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
%	showstringspaces=false, % lets spaces in strings appear as real spaces
%	breaklines=true, % wrap lines if they don't fit
%	frame=trbl, % draw a frame at the top, right, left and bottom of the listing
%	frameround=tttt, % make the frame round at all four corners
%	framesep=4pt, % quarter circle size of the round corners
%	numbers=left, % show line numbers at the left
%	numberstyle=\tiny\ttfamily, % style of the line numbers
%	commentstyle=\color{yarelGreen}, % style of comments
%	keywordstyle=\color{mymauve}, % style of keywords
%	%	stringstyle=\color{yarelBlue}, % style of strings
%	identifierstyle=\color{dblue},
%	stringstyle=\color{orange},
%	backgroundcolor=\color{gray!5},
%	mathescape=true,
%	sensitive=false, % keywords are not case-sensitive
%}
%\newcommand{\verby}[1]{\lstinline[language=yarel,style=yarel-style]+#1+}
%% JAVA related definitions
%\input{java-lst.tex}
%\lstdefinestyle{java-style}{
%	backgroundcolor=\color{backcolour},
%	commentstyle=\color{codegreen},
%	keywordstyle=\color{magenta},
%	numberstyle=\tiny\color{codegray},
%	stringstyle=\color{codepurple},
%	basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
%%	basicstyle=\ttfamily\footnotesize,
%	breakatwhitespace=false,
%	breaklines=true,
%	captionpos=b,
%	keepspaces=true,
%	numbers=left,
%	numbersep=5pt,
%	showspaces=false,
%	showstringspaces=false,
%	showtabs=false,
%	tabsize=2
%}
%\lstset{
%	language={java},
%	morekeywords={cached,case,default,extension,false,import,JAVA,WORKFLOWSLOT,let,new,null,private,create,switch,this,true,reexport,around,if,then,else, def, val, var, private, class, static, return, as, instanceof, for, override, boolean},
%	morekeywords=[2]{filter, toList, last, head},
%	keywordstyle=[2]\color{eclipseOrange}\textit,
%	morekeywords=[3]{FAST, NORMAL, IN, PROVIDED},
%	keywordstyle=[3]\color{eclipseBlue}\textsl,
%	morekeywords=[4]{},          % <-- Your keywords here (w/ orange)
%	keywordstyle=[4]\color{eclipseOrange},
%	morecomment=[l]{//},
%	morecomment=[s]{/*}{*/},
%	morestring=[b]",
%}
%\newcommand{\verbj}[1]{\lstinline[language=java,style=java-style]+#1+}
%\newcommand{\vj}[1]{\lstinline[language=java,style=java-style]+#1+}
%%% lstlisting stop definitions

% Macros
\newcommand{\RPP}{\textsf{RPP}\xspace}
\newcommand{\UPRF}{\textsf{UPRF}\xspace}
\newcommand{\PRF}{\textsf{PRF}\xspace}
\newcommand{\CPP}{\textsf{C}\xspace}
\newcommand{\LEAN}{\textsf{LEAN 3}\xspace}
\newcommand{\LEANFour}{\textsf{LEAN 4}\xspace}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Int}{\mathbb{Z}}
\newcommand{\RPRF}{\mathsf{R}\PRF} % reversible primitive
\newcommand{\JMF}{\mathcal{RI}} % Jacopini Mentrasti


\begin{document}
\title{A formal certification that Reversible Primitive Permutations are Primitive-recursive complete}

\author{Giacomo Maletto\inst{1} \and
	    Luca Roversi\inst{2}\orcidID{0000-0002-1871-6109}}

\authorrunning{G. Maletto, L. Roversi}

\institute{
    Università degli Studi di Torino, Dipartimento di Matematica  -- Italy\\
	\email{giacomo.maletto@edu.unito.it}\\
	\and
	Università degli Studi di Torino, Dipartimento di Informatica -- Italy\\
	\email{luca.roversi@unito.it}}

\maketitle
\begin{abstract}
\end{abstract}

%=====================
\section{Introduction}
\label{section:Introduction}

Mainstream models of computations focus on one of the two possible directions of computation.
We typically think how to model
the way the computation evolves from inputs to outputs while
we (reasonably) overlook the behavior in the opposite direction, from outputs to inputs.
Generally speaking, models of computations are neither backward deterministic nor reversible.

For a very rough intuition about what reversible computation deals with, we start by an example.
Let us think about our favorite programming language and think of implementing the
addition between two natural numbers
$ m $ and $ n $. Very likely --- of course without absolute certainty --- we
shall end up with some procedure \texttt{sum} which takes two arguments and which yields their sum.
For example, \texttt{sum}($ 3 $,$ 2 $) would yield $ 5 $.
What if we think of asking for the values $ m $ and $ n $ such that \texttt{sum}($ m $,$ n $) = $ 5 $?
If we had implemented \texttt{sum} in a prolog-like language, then we could exploit its
non deterministic evaluation mechanism to list all the pairs $ (0,5), (1,4), (2,3), (3,2), (4,1) $ and
$ (5,0) $ every of which would well be a correct instance of ($ m, n $).
In a reversible setting we would obtain
exactly the pair we started from. I.e., the computation would be backward deterministic.
The interest for the backward determinism arose in the sixties of the last century,
studying the thermodynamics of computation and the connections between information theory, computability and entropy.
Since then, the interest for the reversible computing has slowly but incessantly grown.

A forcefully non-exhaustive list of references follows.
Reversible Turing machines are defined in \cite{axelsen11lncs,bennett73ibm,jacopini90siam,lecerf63} while
\cite{axelsen11lncs,axelsen16acta,jacopini89tcs,li1996royal}
study some of their computational theoretic properties.
Many research efforts have been focused on  boolean functions and cellular
automata as models of the reversible
computation \cite{Morita2008101,toffoli80lncs}.
Moreover, some research focused on reversible programming languages \cite{DBLP:conf/popl/JamesS12,yokoyama08acm}.
Of course, the interest to build a comprehensive knowledge about reversible computation is wider than
the mere interest for its computational theoretic aspects.
The book \cite{perumalla2013chc} is a comprehensive
introduction to the subject. It spans from low-power-consumption reversible hardware to emerging alternative computational
models like quantum  \cite{guerriniMM15,zorzi14mscs} or bio-inspired \cite{giannini2015tcs} of which reversibility is one the unavoidable building blocks.

\paragraph{Goal}
The focus of this work is on a \emph{functional model} of reversible computation.
Specifically, we look for a  sufficiently expressive  class of recursive permutations able to represent all
Primitive Recursive Functions ($ \PRF $) \cite{rogers1967theory,soare1987book}
whose relevance is sometimes traced to the slogan
``programs which terminate but do not belong to $ \PRF $ are rarely of practical interest.''


We aim at formalizing a language that we identify as Reversible Primitive Permutations ($ \RPP $) and which
retains the more interesting aspects of $\PRF$.
In analogy to $ \PRF $, our goal is to get a functional characterization of computability
-- but in a reversible setting, of course --- because functions are handier in order to compose
algorithms. Other models, like, for example, Turing machines-oriented ones are
more convincing from an implementation view-point.
The ability to represent Cantor pairing \cite{rosenberg2009book} is one of the main properties that
the functional characterization we are looking for must satisfy.
With Cantor pairing available it is possible to express all interesting total properties about the
traces\footnote{Kleene's $T_n$ predicate, Kleene's normal form theorem and technical tools related to them \cite{cutland1980book,odifreddi1989book,soare1987book}.}
of Turing machines, reversible or not.
The other must-have property of our functional characterization is closure under inversion, which is something
very natural to ask for in a class of permutations and of reversible computing models.

Our quest is challenging because various negative results could have played  against it.
First of all, we remark that the class of all (total) recursive permutations
cannot be effectively enumerated (see \cite[Exercise 4-6, p.55]{rogers1967theory}).
In \cite{koz1972ail} a constructive generation of all the recursive permutations is given starting
from primitive recursive permutations. Since no enumeration exists for the latter, none can exist for the former.
Worst, the class of primitive recursive permutations is not closed under inversion \cite{kuznecov50sssr,PaoliniPiccoloRoversiICTCS2015,soare1987book}.
Since the above negative results hold also for the class of elementary permutations
\cite{cannonito1969jsl,kalimullin03permutations,koz1974ail}, there is no
hope to find any effective description neither of the class of recursive
permutations nor of the classes of primitive recursive permutations and of elementary permutations.


\paragraph{Comparison with the known literature}
Our quest to identify the reversible  analogous of $ \PRF $  must be throughly related to the following works.
\begin{itemize}
    \item
    The programming language $ \mathsf{SRL} $  restricts $ \mathsf{LOOP} $, a language
    for programming $\PRF$ functions \cite{meyer1967acm}.
    Matos introduces $ \mathsf{SRL} $ and some of its variants in \cite{matos03tcs}.
    He is the first using $ \Int $ --- the natural numbers with sign --- as the ground type for
    classes of reversible functions.
    We share the choice with him.
    The work \cite{matos03tcs} focuses on the algebraic aspects of his languages and its relations with
    matrix groups.

    %\todo{Questions 1 and 2, Reviewer 1}
    The study of the classes of functions that $ \mathsf{SRL} $ variants can identify
    is part of Matos' work.
    Variants of $\mathsf{SRL}$ are complete with respect to reversible boolean circuits \cite{matos2016notes}.
    Proving that some given variant of $\mathsf{SRL}$ is $ \mathsf{PRF} $-complete,
    i.e. that it represents all the functions in $ \mathsf{PRF} $, naturally ends up with the quest
    to encode the ``test for 0'' like in the proof that $ \mathsf{LOOP} $ and $ \mathsf{PRF} $ are equivalent \cite{meyer1967acm}.
    We \emph{conjecture} that no variant of Matos' languages exists able to simulate a conditional
    control on the flow of execution that, instead, $ \RPP $ contains by definition.
    Of course, proving the conjecture false, would promote $\mathsf{SRL}$ to be (in a reasonable sense) the minimal reversible and
    $ \mathsf{PRF} $-complete language.

    \item The precursor of this work is \cite{PaoliniPiccoloRoversiICTCS2015}. It introduces the class of functions $ \RPRF $ which is closed by inversion and is $\PRF$-complete.
    The completeness of $ \RPRF $ relies on \emph{built-in} Cantor pairings.
    In this paper we show that we can get rid of \emph{built-in} Cantor pairings inside $ \RPP $.
    With no \emph{built-in} pairing operators at hand the design of $ \RPP $ relies on operators which are more fine-grained as compared
    to the ones used for the definition of $ \RPRF $.
    This orients the programming style to enjoy a couple of interesting features.
    Inside $ \RPP $ it is natural avoiding to save the entire history of a calculation within a single argument, i.e. into a single ancilla.
    This allows to clean the garbage at the end of the simulation of any $ f\in\PRF $, something which is reminiscent of the simulation
    of Turing machines devised in \cite{bennett1989siamjc}.

    \item
    Finally we discuss \cite{jacopini89tcs}.
    It introduces the class of reversible functions $ \JMF $ which is as expressive as Kleene's
    partial recursive functions \cite{cutland1980book,odifreddi1989book}.
    Therefore, the focus of \cite{jacopini89tcs} is on partial reversible functions while ours  is on total ones.
    The expressiveness of $ \JMF $ is clearly stronger than the one of  $ \RPP $.
    However, we see $ \JMF $ as less abstract than $ \RPP $ for two reasons.
    On one side, the primitive functions of $ \JMF $ relies on a given specific binary representation of natural numbers.
    On the other, it is not evident that $ \JMF $ is the extension of a total sub-class
    analogous to $ \RPP $ which should ideally correspond to $ \PRF $, but in a reversible setting.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Contents}
We propose a formalism that identifies a class of functions which we call Reversible Primitive Permutations
($ \RPP $) and which is strictly included in the set of permutations.
Section~\ref{section:The class RPP of Reversible Primitive Permutations} defines $ \RPP $ in analogy
with the definition of $ \PRF $, I.e. $ \RPP $ is the closure of composition schemes on basic functions.

The functions of $ \RPP $ have identical arity and co-arity and take
$ \Int $ --- and not only $ \Nat $ --- as their
domain because $ \Nat $ is not a group. So, $ \RPP $ is sufficiently abstract
to avoid any reference to any specific
encoding of numbers and strongly connects our work to Matos' one \cite{matos03tcs}.

For example, in $ \RPP $ we can define a \texttt{sum} that given the two integers $ m $ and $ n $
yields $ m+n $ and $ n $. Let us represent \texttt{sum} as:
\begin{align}
    \label{align:sum example}
    \arraycolsep=1.4pt
    \begin{array}{rcl}
        \left. {\scriptsize \begin{array}{r} m    \\ n \end{array}} \right[
        & \texttt{sum} &
        \left] {\scriptsize \begin{array}{l} m + n\\ n \end{array} } \right.
    \end{array}
    \enspace .
\end{align}
The implementation of \texttt{sum} inside $ \RPP $ exploits an iteration scheme that iterates $ n $
times the successor, starting on the initial value $ m $ of the first input.
$ \RPP $ implies the existence of a (meta and) \emph{effective} procedure which produces
the inverse $ rprInv{f}\in\RPP $ of every given $ f\in\RPP $.
I.e., :
\begin{align}
    \label{align:diff example}
    \arraycolsep=1.4pt
    \begin{array}{rcl}
        \left. {\scriptsize \begin{array}{r} p    \\ n \end{array}} \right[
        & rprInv{\texttt{sum}}
        &
        \left] {\scriptsize \begin{array}{l} p - n\\ n \end{array} } \right.
    \end{array}
\end{align}
belongs to $ \RPP $ and it ``undoes'' \texttt{sum} by iterating $ n $ times
the predecessor on $ p $. So if $ p = m + n $, then $ p - n = m + n - n = m$.
We remark we could have internalized the operation that yields the inverse of a
function inside $\RPP$ like in \cite{matos03tcs}. We do not internalize it
to avoid mutually recursive definitions in $ \RPP $.

Concerning the \emph{expressiveness}, $ \RPP $ is closed under inversion and it is both $ \PRF $-complete and $ \PRF $-sound.
Completeness is the really relevant property between the two because this means that
$ \RPP $ subsumes the class $ \PRF $.
This result is in  Section~\ref{section:Completeness of RPP}. It requires quite a lot
of preliminary work that one can find in Sections~\ref{section:Generalizations inside RPP},
\ref{section:A library of functions in TRRF} and~\ref{section:Cantor pairing}
and whose goal is to encode a bounded minimalization and Cantor pairing.
The embedding relies on various key aspects of reversible computing. The principal
ones are:  (i) the use of ancillary variables to clone information
and (ii) the compositional programming under the pattern that Bennett's trick dictates
(cf. Section~\ref{section:Some recursion theoretic side effects of RPP}.)




\subsection{Contributions}
\begin{itemize}
    \item We give a strong guarantee that \RPP is \PRF-complete.
    Relying on the correctness of existing proofs between the classes \PRF and \UPRF, using the proof-assistant \LEAN, we prove that every function in \UPRF can be represented and simulated by a suitable function in \RPP.

    Despite we work out the proof in full details, besides fixing some small bugs, we also conceptually and technically simplify the original proof in  \cite{DBLP:journals/tcs/PaoliniPR20}.

    \item On one side the simplification is a consequence of the representation of \UPRF available as a \LEAN library. On the other, and more remarkably, it consists of a complete reworking, as compared to \cite{DBLP:journals/tcs/PaoliniPR20}, of the Cantor Pairing \cite{???} as a function of \RPP. We recall that Cantor Pairing is an isomorphism $ \mathbb{N}\times\mathbb{N} \simeq \mathbb{N} $. We use Cantor Pairing  as a stack that allows us to correctly manage the computation of a recursive scheme of \UPRF by means of a reversible computation of an element in \RPP.

    \item The \RPP function that we introduce to implement Cantor Pairing is a specific instance of a more general pattern that allows to uniquely associate pairs of $ \mathbb{N}\times\mathbb{N}$ to single element of $ \mathbb{N}$. This means that we are able to show further isomorphims  $ \mathbb{N}\times\mathbb{N}\simeq \mathbb{N}$ in \RPP by just modifying a core element in the definition the Cantor Pairing.

    \item The side-effect of the whole work is twofold:
    \begin{itemize}
        \item We supply concrete and not always immediate examples of reversible programming in \LEAN. This has a value per se, because programming reversible algorithms is not as much wide-spread as iterative, or recursive, programming in classical programming formalisms.
        \item \LEANFour will be delivered in the near future. \LEANFour will come with the possibility to export its source code as efficient \CPP code \cite{2021-LEAN4-MouraUllrich}. The migration from \LEAN to \LEANFour will allow us to export our reversible algorithms as efficient extensions of \LEANFour, or as standalone, and possibly reversible, applications written in \CPP.
    \end{itemize}
\end{itemize}

%---------------------
\subsection{Related work}

%---------------------
\subsection{Road map}


%=====================
\section{Reversible Primitive Permutations (\RPP) }
\label{section:Reversible Primitive Permutations}

%=====================
\section{Unary Primitive Recursive Functions (\UPRF) }
\label{section:Unary Primitive Recursive Functions}

%=====================
\section{The \UPRF-completeness of \RPP}
\label:{section:The UPRF-completeness of RPP}

%=====================
\section{Why \LEAN and not other proof assistant?}
\label{section:Why LEAN and not other proof assistant?}

%=====================
\section{Conclusion and developments}
\label{section:Conclusion and developments}

%------------------
\bibliographystyle{abbrv}
\bibliography{bib-minimal}

%\appendix

\end{document}