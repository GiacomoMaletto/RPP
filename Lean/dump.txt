def tr := It (Su ;; inc)

@[simp] lemma tr_arity : tr.arity = 3 := rfl

lemma tr_def (n : ℕ) : ‹tr› [n, 0, 0] = [n, n, (iota n).sum] :=
begin
  rw [tr, ev, int.to_nat_coe_nat], congr,
  induction n with n hn, refl,
  rw [function.iterate_succ_apply', hn], simp [ev],
  norm_cast, rw inc_def, simp[iota], ring
end

def cp := inc ;; Id1 ‖ (tr ;; dec) ;; dec ;;
  ⌊0, 3, 1⌉ ;; inc ;; ⌊0, 2, 1⌉

def cp_fn (n m : ℕ) := (iota (n + m)).sum + n

lemma cp_def (n m : ℕ) : ‹cp› [n, m, 0, 0] = [n, m, cp_fn n m, 0] :=
begin
  simp [cp, ev],
  conv { to_lhs,
  conv { congr, skip,
  conv { congr, skip,
  conv { congr, skip,
  conv { congr, skip,
  conv { congr, skip,
  conv { congr, skip,
  conv { congr, skip,
  rw ev_split, simp, rw inc_def, simp },
  rw ev_split, simp, rw add_comm, norm_cast, rw tr_def },
  rw ev_split, simp, norm_cast, rw dec_def, simp },
  rw ev_split, simp, rw inc_def, simp },
  rw ev_split, simp, rw dec_def, simp },
  rw rewire, simp [ev] },
  rw ev_split, simp, rw inc_def, simp },
  rw rewire, simp [ev] },
  rw [cp_fn], refl
end

def cu_step :=
  Su ‖ If Su Id1 Id1 ;;
  ⌊2, 0, 1⌉ ;;
  If (Id1 ‖ Pr) Sw Id1 ;;
  Sw ;; If Pr Id1 Id1 ;;
  Id1 ‖ Sw

def cu := It cu_step

lemma cp_succ_l (n m : ℕ) : cp_fn n.succ m = cp_fn n m + n + m + 2 :=
by { simp [cp_fn], rw nat.succ_add, simp[iota], omega }

lemma cp_succ_r (n m : ℕ) : cp_fn n m.succ = cp_fn n m + n + m + 1 :=
by { simp [cp_fn], rw nat.add_succ, simp[iota], omega }

@[simp] lemma if_one (f g h : RPP) (l : list ℤ): ‹If f g h› (1 :: l) = 1 :: ‹f› l := rfl

lemma cu_step_def (n m : ℕ) : ‹cu_step› [n, m + 1, 0] = [n + 1, m, 0] :=
by { rw [cu_step], simp [rewire, ev] }

lemma cu_step_def' (n : ℕ) : ‹cu_step› [n, 0, 0] = [0, n + 1, 0] := rfl

lemma cu_step_of_le (n m k : ℕ) (h : k ≤ m) :
  ‹cu_step›^[k] [n, m, 0] = [n + k, m - k, 0] :=
begin
  induction k with k hk, refl,  
  rw [function.iterate_succ_apply', hk (nat.le_of_succ_le h)], norm_cast,
  have h₁ : k ≤ m, by exact nat.le_of_succ_le h,
  calc ‹cu_step› [↑(n + k), ↑m - ↑k, 0]
      = ‹cu_step› [↑(n + k), ↑(m - k), 0]          : by { congr, rw int.coe_nat_sub h₁ }
  ... = ‹cu_step› [↑(n + k), ↑(m - k.succ) + 1, 0] : by { congr, omega }
  ... = [↑(n + k) + 1, ↑(m - k.succ), 0]           : by rw cu_step_def
  ... = [↑(n + k.succ), ↑(m - k.succ), 0]          : rfl,
end

lemma cu_step_ind_r (n m : ℕ) (h : ‹cu_step›^[cp_fn n m] [0, 0, 0] = [n, m, 0]) :
  ‹cu_step›^[cp_fn n m.succ] ([0, 0, 0] : list ℤ) = ([n, m.succ, 0] : list ℤ) :=
begin
  calc ‹cu_step›^[cp_fn n m.succ] [0, 0, 0]
      = (‹cu_step›^[cp_fn n m + n + m + 1]) [0, 0, 0]   : by rw cp_succ_r
  ... = (‹cu_step›^[(n + 1 + m) + cp_fn n m]) [0, 0, 0] : by { congr' 1, ring }
  ... = (‹cu_step›^[n+1+m]) (‹cu_step›^[cp_fn n m] [0,0,0]) : by rw function.iterate_add_apply
  ... = (‹cu_step›^[n + 1 + m]) [n, m, 0]               : by rw h
  ... = (‹cu_step›^[n + 1]) (‹cu_step›^[m] [n, m, 0])   : by rw function.iterate_add_apply
  ... = (‹cu_step›^[n + 1]) [n + m, m - m, 0]           : by { rw cu_step_of_le, refl }
  ... = (‹cu_step›^[n + 1]) [n + m, 0, 0]               : by ring_nf
  ... = (‹cu_step›^[n]) [0, n + m + 1, 0]               : by norm_cast
  ... = (‹cu_step›^[n]) [↑0, ↑(n + m + 1), 0]           : by norm_cast
  ... = [↑0 + ↑n, ↑(n + m + 1) - ↑n, 0]                 : by { rw cu_step_of_le, linarith }
  ... = [n, ↑(n + m + 1) - ↑n, 0]                       : by { congr, norm_cast, ring }
  ... = [n, ↑(n + m + 1 - n), 0]                        : by { rw ←int.coe_nat_sub, linarith }
  ... = [n, m.succ, 0]                                  : by { congr, omega }
end

lemma cu_step_ind_l (n m : ℕ) (h : ‹cu_step›^[cp_fn n m] [0, 0, 0] = [n, m, 0]) :
  ‹cu_step›^[cp_fn n.succ m] ([0, 0, 0] : list ℤ) = ([n.succ, m, 0] : list ℤ) :=
begin
  calc ‹cu_step›^[cp_fn n.succ m] [0, 0, 0]
      = (‹cu_step›^[cp_fn n m + n + m + 1 + 1]) [0, 0, 0]  : by rw cp_succ_l
  ... = (‹cu_step›^[cp_fn n m.succ + 1]) [0, 0, 0]         : by rw ←cp_succ_r
  ... = ‹cu_step› ((‹cu_step›^[cp_fn n m.succ]) [0, 0, 0]) : by rw function.iterate_succ_apply'
  ... = ‹cu_step› [n, m.succ, 0]                           : by rwa cu_step_ind_r
  ... = [n.succ, m, 0]                                     : by { simp, rw cu_step_def }
end

lemma cu_def (n m : ℕ) : ‹cu› [cp_fn n m, 0, 0, 0] = [cp_fn n m, n, m, 0] :=
begin
  simp [cu, ev], induction n with n hn; induction m with m hm,
  refl,
  rwa cu_step_ind_r,
  rwa cu_step_ind_l,
  rwa cu_step_ind_l
end

def push := cp ;; ⌊2, 0, 1⌉ ;; cu⁻¹

theorem push_def (n m : ℕ) : ‹push› [n, m, 0, 0] = [cp_fn n m, 0, 0, 0] :=
begin
  rw push, simp [ev],
  rw [cp_def], simp [rewire, ev],
  rw [proposition_1, cu_def]
end